---
layout: default
---

# RISC-V 双周简报 (2018-01-04)

要点新闻：


## RV新闻


## 技术讨论

### 支持semi-host

很多指令集都支持使用调试器来实现一些简单的I/O功能以方便系统的早期调试。
这时候，调试器便起到了一部分主机的功能，即称作semi-host。
由于调试器的可见中断只有EBREAK指令，所以实现semi-host必须在这条指令上想办法。
在RISC-V指令集定义的时候，EBREAK指令被定义为不带任何操作数的指令，其[基本考虑](https://groups.google.com/a/groups.riscv.org/d/msg/isa-dev/1Su9Z7L18qM/zP_Yy5dRBQAJ)如下：

> From Krste:
>
> - A debugger knows the addresses at which it has inserted breakpoints.
>   (调试器应该知道源代码中的断点位置)
>
> - When the debugger is notified that a hart has stopped at a
>   breakpoint, it needs to read the pc at least.
>   (当调试器被断点唤醒，调试器至少会读取当前PC指针)
>
> - A debugger-side hashtable indexed by the pc can uncover all the
>   necessary information about that breakpoint without having to go
>   back and read the EBREAK instruction bits from target memory, and
>   without being constrained by the size of the EBREAK immediate field.
>   (使用一个简单的哈希表应该就能很快分析出断点的功能，而不需要去分析断点指令的参数)
>
> - A compressed EBREAK should work the same as an uncompressed EBREAK,
>   and encoding space is more critical in compressed code.
>   (压缩和非压缩断点指令的行为应当一致)
>
> - More generally, we viewed EBREAKs as instructions that are poked
>   into compiled code from outside, not instructions that are compiled
>   in to a binary, though it's clear software breakpoints are being
>   used in this way for other architectures.
>   (从根本上说，断点指令应当被看作被外部添加的指令，而不是原有执行程序的固有指令。尽管软中断被其他的体系结构大量使用为软件基本功能)

上面的软件中断即暗指ARM系列的软终端，想起来了ARM 7中SWI \#imm的用法吗？

不过这些基本假设现在似乎出现了问题。
比如，Liviu就指出，调试器并不是任何时候都能拿到被调试代码的执行副本的(思考直接将调试器接到一个嵌入式系统盲调)。
这这种时候，就不能假设调试器能独立理解断点所需要的功能。

为了解决这个问题，Liviu提议改变EBREAK的格式，添加一个立即数参数。但是这样便破坏了已经被定义的用户态RISC-V指令级标准。
作为折衷方案，Krste提出：

> - Use EBREAK + 16-bit zero + 16-bit tag as current workaround to lack
>   of EBREAK immediate (effectively making a new 64-bit EBREAK encoding).
>   (仍然使用现在的EBRAK指令，不过在指令后添加一个16比特0的非法指令做标识符，然后使用一个16比特作为断点参数)
>
> - Add "undelegate" feature to debug spec so ECALL (and other
>   exceptions/interrupts) can trap to debugger.
>   (为系统调用ECALL提供调试器的接口，让部分系统调用由调试器完成)
>
> - Move eventually to using ECALL for semihosting-like applications
>   where debug hardware supports "undelegate".
>   (逐步推进使用系统调用实现semi-host的大部分功能)
>
> - Use labeled ELF for EBREAK "assert failure" use cases.
>   (使用断点和执行文件副本实现assert)

但是即使这样也不能满足所有需求。
其中反映最激烈的问题是使用系统调用的方式实现semi-host导致每次host调用都必须陷入异常处理，
这对于使用semi-host来实现轻量级打印输出来说代价过大。
用semi-host的方式实现轻量级打印输出是trace调试的基本操作之一，
在系统早期调试硬件和基础软件，trace调试是非常有用的。
所以支持这种轻量级的semi-host也是很有必要。

现在这个讨论还在继续中，决定之后，RISC-V的调试标准将会做相应修改。
现在看来，对于I/O的semi-host应用会使用系统调用方式，而对于打印调试信息则可能使用断点叫附加断点参数的方式。

相关讨论：https://groups.google.com/a/groups.riscv.org/d/msg/isa-dev/1Su9Z7L18qM/QCDxYoCCBwAJ

### 使用32比特的NOP指令隐藏一条16比特指令？

这个技巧还真是令人大开眼界。假设下面的程序：

```c
if(a>0) b=b+1;
else    b=b-1;
```

这段小程序的`else`分支只有一条指令。一般编译器会在`if`分支的最后加一条跳转指令跳到`else`分支之后的代码。
但是由于`else`分支只有一条指令，与其使用跳转指令，可以使用一条类似`LUI x0, #imm20`的NOP指令（`x0`寄存器永远为0，所以赋值没有意义），
然后将`else`分支的指令用一条RVC指令代替，然后将其藏在20比特的立即数里。很有点脑洞大开。

这么做的主要意义是节省指令空间，据说在以前的ROM大小受限的Z80系统经常会使用这种技巧。
在现代处理器中，这种使用方式基本不会带来任何速度优势（分支预测能很准确地预测跳转），但可能造成取指（Fetch）部分的错误。
不过对于系统初始环节，在初始内存受限情况下，也许有其用途。

- sw-dev上的讨论：https://groups.google.com/a/groups.riscv.org/d/msg/sw-dev/LVjUJIPGE_4/TPHT19yKCQAJ


## 代码更新

## 安全点评

## 微群热点

## 实用资料

### Linux kernel Upstream的内容（Palmer 的 All Aboard, Part 8: The RISC-V Linux Port is Upstream!）

Palmer在这篇中记录了 4.15中 Upstream的内容，同时也讲了哪些还需要加强。还需要加强的部分包括memory model、PLIC、DMA、timer、device tree文档、以及SBI console driver。想了解Linux kernel整体的情况的话，可以参考。想了解更多更新，也可以追踪 patches@groups.riscv.org。

连结：[All aboard part 8 ](https://www.sifive.com/blog/2017/12/05/all-aboard-part-8-the-risc-v-linux-port-is-upstream/)


### Palmer 的 All Aboard, Part 9: Paging and the MMU in the RISC-V Linux Kernel

前半段Palmer先介绍了 RISC-V 系统中的 AEE (Application Execution Environment)和 SEE (Supervisor Execution Environment)。在RISC-V中，AEE的部分基本要求包括(小编：scall在2.1中其实已经被更名为ecall)：

> The ISA string, which determines what the vast majority of instructions do as well as which registers constitute the machine’s current state.
> 
> The supervisor’s user-visible ABI, which determines what the scall instruction does. This is different than the C compiler’s ABI, which defines the interface between different components of the application.
> 
> The contents of the entire memory address space.

当然，实际上AEE还是要看各操作系统决定的，譬如FreeBSD 和 Linux的AEE就不同。至于Unix-class 的 SEE，则是会由Platform spec 小组订出一些基本要求，Palmer所猜测的定义如下(除了PMA和SBI以外，这跟workshop时小编记录的类似）：

> Either the RV32I or RV64I base ISAs, along with the M, A, and C extensions. The F and D extensions are optional but paired together, leaving the possible standard ISAs for application-class SEEs as RV32IMAC, RV32IMAFDC (RV32GC), RV64IMAC, and RV64IMAFDC (RV64GC).
> 
> On RV32I-based systems, support for Sv32 page-based virtual memory.
> 
> On RV64I-based systems, support for at least Sv48 page-based virtual memory.
> 
> Upon entering the SEE, the PMAs are set such that memory accesses are point-to-point strongly ordered between harts and devices.
> 
> An SBI that implements various fences, timers, and a console.

在介绍完AEE和SEE这些系统基本的要求后，Palmer整理了一些risc-v中 page table的特点：
> Pages are 4KiB at the leaf node, and it’s possible to map large contiguous regions with every level of the page table.
> 
> RV32I-based systems can have up to 34-bit physical addresses with a three level page table.
> 
> RV64I-based systems can have multiple virtual address widths, starting with 39-bit and extending up to 64-bit in increments of 9 bits.
> 
> Mappings must be synchronized via the sfence.vma instruction.
> 
> There are bits for global mappings, supervisor-only, read/write/execute, and accessed/dirty.
> 
> There is a single valid bit, which allows storing XLEN-1 bits of flags in an otherwise unused page tables. Additionally, there are two bits of software flags in mapped pages.
> 
> Address space identifiers are 9 bits or RV32I and 16 bits on RV64I, and they’re a hint so a valid implementation is to ignore them.
> 
> The accessed and dirty bits are strongly ordered with respect to accesses from the same hart, but are optional (with a trap-based mechanism when unsupported)
> 

值得注意的是，像ASID这种额外功能在risc-v的 Linux kernel中其实还没实作。有兴趣的同学可以把握机会。最后，Palmer介绍了跟device 和DMA有关的部分。因为risc-v 没有定义IOMMU，目前risc-v linux kernel 使用 bounce buffer 及 32bit ZOME_DMA 来处理 device addressing的问题。

更多细节可以参考: [Palmer 的 All aboard part 9](https://www.sifive.com/blog/2017/12/11/all-aboard-part-9-paging-and-mmu-in-risc-v-linux-kernel/)

### Sodor 的设计文档
Shimomura Shigeki 整理了一份约20页的Sodor design doc，详细整理了code structure和每一个档的作用。有在用sodor研究risc-v，或想学chisel的可以参考。

连结：[Sodor design doc](https://docs.google.com/document/d/1WPQblOoKIODLrIacFSumXR6_uC9zquyixNFN8ABVQxY/edit?usp=sharing)

### 另一个chisel的学习资料：Berkeley 的 Generator Bootcamp
想透过学chisel学习rocket和BOOM的同学可以参考这个新的repo。这个 repo 用 Jupyter Notebook 来教怎么用chisel写generator。另外，chisel learning journey 的文档也在不断更新，也可以参考或加入chisel learning journey的hangout。

连结1：[Generator Bootcamp](https://github.com/ucb-bar/generator-bootcamp)

连结2: [chisel learning journey的更新](https://github.com/librecores/riscv-sodor/wiki)



## 行业视角

## 市场相关


## CNRV社区活动

## CNRV网站更新


## 暴走事件



### 二月

+ [FOSDEM'18](https://fosdem.org/2018/) 2018年2月3-4日，FOSDEM (Free and Open Source Developers’ European Meeting)将在比利时的布鲁塞尔举行。

+ [PULP WORKSHOP AT HPCA2018](http://pulp-platform.org/hpca2018) 2018年2月25日，在维也纳的HPCA中，会有一场跟Pulp 有关的workshop。PULP小组会介绍PULP最新的发展，和他们未来的走向，包括  PULP-CAPI (Coherent Accelerator Processor Interface) 和 Ariane （Next generation of 64-bit RISC-V implementations）等。详情可参考 pulpino mailing list 中的 < PULP newsletter - 4Q2017 >。


## 招聘简讯

_CNRV提供为行业公司提供公益性质的一句话的招聘信息发布，若有任何体系结构、IC设计、软件开发的招聘信息，欢迎联系我们！_

----

整理编集: 宋威、黄柏玮、郭雄飞


----

**欢迎关注微信公众号CNRV，接收最新最时尚的RISC-V讯息！**

![CNRV微信公众号](/assets/images/cnrv_qr.png)

----

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/cn/80x15.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/">知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议</a>进行许可。

